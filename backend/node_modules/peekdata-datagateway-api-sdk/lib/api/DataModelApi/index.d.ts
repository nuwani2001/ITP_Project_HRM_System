import { ICompatibilityResponse, INode, IValidationResponse } from '../../models/datamodel';
import { ICompatibilityCheckRequest } from '../../models/report';
import { IRequestOptions } from '../../models/request';
import { BaseApi } from '../base';
export declare class DataModelApi extends BaseApi {
    /**
     * Gets list of scope names
     */
    getScopeNames: (requestOptions?: IRequestOptions) => Promise<string[]>;
    /**
     * Gets list of data model names
     */
    getDataModelNames: (scopeName: string, requestOptions?: IRequestOptions) => Promise<string[]>;
    /**
     * Gets list of cube names
     */
    getCubeNames: (scopeName: string, dataModelName: string, requestOptions?: IRequestOptions) => Promise<string[]>;
    /**
     * Gets list of data model's dimensions
     * @param securityRole used to filter dimensions
     */
    getDimensions: (scopeName: string, dataModelName: string, securityRole?: string, requestOptions?: IRequestOptions) => Promise<INode[]>;
    /**
     * Gets list of data model's metrics
     * @param securityRole used to filter metrics
     */
    getMetrics: (scopeName: string, dataModelName: string, securityRole?: string, requestOptions?: IRequestOptions) => Promise<INode[]>;
    /**
     * As Data API should receive valid combinations of dimensions and metrics, request should be validated first.
     * If combination is not valid, field "isValid" will return false with detailed description contained in "reason".
     */
    validate: (request: ICompatibilityCheckRequest, requestOptions?: IRequestOptions) => Promise<IValidationResponse>;
    /**
     * Gets valid dimensions and metrics
     */
    getCompatibleNodes: (request: ICompatibilityCheckRequest, requestOptions?: IRequestOptions) => Promise<ICompatibilityResponse>;
}
